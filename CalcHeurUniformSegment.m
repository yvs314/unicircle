%% CalcHeurUniform Эвристический расчет равномерного распределения на отрезке
%
% Функция рассчитывает "эвристически равномерное" распределение L точек по N слотам
%
% Точки и слоты расположены на отрезке (аналогично дуге окружности);
% слоты выставлены на равных расстояниях, от 1 до N.
% Предполагается, что "соседние" слоты 0 и N+1 заняты, а расстояния
% [0, первая_точка] и [последняя_точка N+1] принимаются в расчет при распределении
% точек по всему отрезку. Получается L + 1 отрезков между L точками.
%

% Я ожидаю (ЯС), что с ростом N это решение приближается к (непрерывному) равномерному распределению.
% Решение точное, когда N + 1 нацело делится на L + 1.
%
% Критерий качества решения здесь средняя длина отрезка, в сравнении с $N + 1 / L + 1$,
% соответствующему непрерывному равномерному распределению

function w = CalcHeurUniformSegment (N, L)

if(N < L)
  error("Точек больше, чем мест под них");
end

Ni = int16(N); % Всего слотов
supp = 0:N+1; % Слоты 0 и N+1 заняты; слоты 1,...,N свободны
Li = int16(L); % Всего точек в решении
seg_count = Li+1; % при размещении 0-> L точек -> N+1 будет L+1 отрезков

base_seg_length = idivide(Ni+1, Li+1);
remainder = mod(Ni+1, Li+1); % осталось еще распределить между отрезками

% Базовая длина отрезка: Ni + 1 / Li + 1 (частное при делении нацело)
rep_base = repmat(base_seg_length, 1, Li + 1);
% Остаток от деления распределим по 1 на каждый отрезок, пока не используем весь
% Апгрейд (не реализовано): вместо концентрации в начале, распределить нули и единицы равномерно
addendum = [ones(1, remainder), zeros(1, Li + 1 - remainder)];

% "Эвристически равномерные" длины отрезков (более длинные вначале)
seg_lengths = rep_base + addendum;

% Получим номера L точек из длин отрезков; отбросим "технические" 0 и N+1
w = cumsum([0 seg_lengths])(2:end-1);
end
